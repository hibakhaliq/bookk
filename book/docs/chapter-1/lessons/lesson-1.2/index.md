---
sidebar_position: 7
---

# Lesson 1.2: ROS 2 Basics

## Learning Objectives

After completing this lesson, you will be able to:
- Understand the basic concepts of ROS 2
- Install and set up a ROS 2 environment
- Create and run simple ROS 2 nodes
- Understand the ROS 2 workspace structure
- Use basic ROS 2 commands

## Introduction

The Robot Operating System 2 (ROS 2) is not an operating system but rather a flexible framework for writing robot software. It is a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robotic platforms.

## What is ROS 2?

ROS 2 is the next generation of the Robot Operating System, designed to address limitations of the original ROS while maintaining its powerful features. Key improvements include:

- **Real-time support**: Better support for real-time applications
- **Deterministic behavior**: More predictable system behavior
- **Security**: Built-in security features for safe multi-robot systems
- **Quality of Service (QoS)**: Configurable communication guarantees
- **DDS-based architecture**: Uses Data Distribution Service for communication

## Installing ROS 2

### System Requirements
- Ubuntu 22.04 (Jammy Jellyfish) or later
- Python 3.8 or higher
- At least 2GB RAM (4GB recommended)

### Installation Steps

1. **Set locale**
```bash
locale  # check for UTF-8
sudo apt update && sudo apt install locales
sudo locale-gen en_US.UTF-8
sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
export LANG=en_US.UTF-8
```

2. **Add ROS 2 apt repository**
```bash
sudo apt install software-properties-common
sudo add-apt-repository universe
sudo apt update && sudo apt install curl gnupg lsb-release
curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key | sudo gpg --dearmor -o /usr/share/keyrings/ros-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null
```

3. **Install ROS 2 packages**
```bash
sudo apt update
sudo apt install ros-humble-desktop
```

4. **Install colcon build tool**
```bash
sudo apt install python3-colcon-common-extensions
```

## Setting up Your Environment

After installation, source the ROS 2 setup script:
```bash
source /opt/ros/humble/setup.bash
```

To automatically source the script in new terminals, add it to your bashrc:
```bash
echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc
```

## ROS 2 Workspace Structure

A typical ROS 2 workspace has the following structure:

```
ros2_workspace/          # Source workspace root
├── src/                 # Source directories
│   ├── robot_package1/
│   │   ├── CMakeLists.txt
│   │   ├── package.xml
│   │   └── robot_package1/
│   │       ├── __init__.py
│   │       └── some_module.py
│   └── robot_package2/
├── build/               # Build artifacts (generated by colcon build)
├── install/             # Install space (generated by colcon build)
└── log/                 # Build logs
```

## Basic ROS 2 Concepts

### Nodes
A node is an executable that uses ROS 2 to communicate with other nodes. Nodes are organized into packages.

### Packages
Packages are the software organization unit in ROS 2. Each package can contain libraries, executables, configuration files, and other resources.

### Topics
Topics are named buses over which nodes exchange messages. Publishers send messages to topics, and subscribers receive messages from topics.

### Services
Services provide a request/reply communication pattern where a node sends a request and receives a response.

### Actions
Actions are a goal-oriented communication pattern with feedback and status updates.

## Creating Your First ROS 2 Package

Let's create a simple package to demonstrate ROS 2 concepts:

```bash
# Create a new workspace directory
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws

# Create a new package
ros2 pkg create --build-type ament_python my_first_robot --dependencies rclpy std_msgs
```

This creates a Python-based ROS 2 package with dependencies on rclpy (Python ROS client library) and std_msgs (standard message types).

## Basic ROS 2 Commands

### Node Management
```bash
# List active nodes
ros2 node list

# Get information about a specific node
ros2 node info <node_name>
```

### Topic Management
```bash
# List active topics
ros2 topic list

# Echo messages on a topic
ros2 topic echo <topic_name> <msg_type>

# Publish a message to a topic
ros2 topic pub <topic_name> <msg_type> <args>
```

### Service Management
```bash
# List active services
ros2 service list

# Call a service
ros2 service call <service_name> <srv_type> <request_args>
```

## Simple Publisher Example

Create a simple publisher in Python:

```python
# my_first_robot/my_first_robot/simple_publisher.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimplePublisher(Node):
    def __init__(self):
        super().__init__('simple_publisher')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    simple_publisher = SimplePublisher()
    rclpy.spin(simple_publisher)
    simple_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Simple Subscriber Example

Create a simple subscriber in Python:

```python
# my_first_robot/my_first_robot/simple_subscriber.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimpleSubscriber(Node):
    def __init__(self):
        super().__init__('simple_subscriber')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    simple_subscriber = SimpleSubscriber()
    rclpy.spin(simple_subscriber)
    simple_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Running the Publisher and Subscriber

1. **Build the package**
```bash
cd ~/ros2_ws
colcon build --packages-select my_first_robot
source install/setup.bash
```

2. **Run the publisher in one terminal**
```bash
ros2 run my_first_robot simple_publisher
```

3. **Run the subscriber in another terminal**
```bash
ros2 run my_first_robot simple_subscriber
```

## Key Takeaways

1. ROS 2 is a middleware framework for robot software development
2. It provides tools for communication between robot software components
3. The basic communication patterns are topics (pub/sub), services (req/rep), and actions (goal-based)
4. Understanding the workspace structure is crucial for development
5. Basic ROS 2 commands help with system introspection and debugging

## Next Steps

In the next lesson, we'll explore Gazebo simulation and how to create virtual robots for testing. This will complement the ROS 2 concepts with practical simulation skills.

## Exercises

1. Install ROS 2 on your development machine
2. Create a new ROS 2 package with publisher and subscriber nodes
3. Run the publisher and subscriber to verify communication
4. Experiment with different message types and topics
5. Explore the ROS 2 command-line tools to understand your system